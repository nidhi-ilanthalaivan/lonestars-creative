Inside out hq enhanced Â· HTML
Copy

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Inside Out HQ - Memory Console</title>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&family=Nunito:wght@700;900&display=swap" rel="stylesheet">
    <style>
        /* --- 1. THEME & UI --- */
        body {
            margin: 0;
            overflow: hidden;
            background-color: #050510;
            font-family: 'Nunito', sans-serif;
            user-select: none;
        }

        /* HEADQUARTERS BACKGROUND */
        #bg-gradient {
            position: absolute; width: 100%; height: 100%;
            /* Authentic HQ purple/blue gradient */
            background: radial-gradient(circle at center 50%, #5a2d8a 0%, #3a1a5a 30%, #1a0a30 60%, #0a0515 100%);
            z-index: -2;
        }

        /* Atmospheric glow particles */
        .dust {
            position: absolute; width: 100%; height: 100%; top: 0; left: 0;
            background-image: 
                radial-gradient(2px 2px at 20% 30%, rgba(255,215,0, 0.6), transparent),
                radial-gradient(2px 2px at 60% 70%, rgba(74,144,226,0.6), transparent),
                radial-gradient(1.5px 1.5px at 80% 20%, rgba(127,214,127,0.5), transparent),
                radial-gradient(2px 2px at 30% 80%, rgba(163,89,255,0.5), transparent),
                radial-gradient(1px 1px at 90% 50%, rgba(255,255,255,0.4), transparent);
            background-size: 800px 800px;
            animation: drift 25s infinite linear;
            opacity: 0.7; z-index: -1;
        }
        @keyframes drift { 
            from { background-position: 0 0; } 
            to { background-position: 800px 800px; } 
        }

        /* LOGO */
        .logo-container {
            position: absolute; top: 3%; left: 50%; transform: translateX(-50%);
            text-align: center; pointer-events: none; z-index: 10;
            filter: drop-shadow(0 0 20px rgba(0,0,0,0.8));
        }
        .logo-main {
            font-family: 'Fredoka One', cursive; font-size: 5rem; color: #fff;
            -webkit-text-stroke: 4px #2962cc;
            text-shadow: 4px 4px 0 #2962cc, 0 0 30px rgba(41,98,204,0.6);
            line-height: 0.85;
        }
        .logo-sub {
            font-family: 'Fredoka One', cursive; font-size: 4rem; color: #ffd700;
            -webkit-text-stroke: 3px #d35400;
            text-shadow: 3px 3px 0 #d35400, 0 0 30px rgba(255,215,0,0.6);
            display: block;
        }

        /* INFO PANEL */
        #info-panel {
            position: absolute; top: 50%; left: 50%;
            transform: translate(-50%, -50%) scale(0.8);
            width: 450px;
            background: linear-gradient(135deg, rgba(40, 30, 70, 0.95), rgba(20, 15, 45, 0.95));
            border: 4px solid rgba(255, 255, 255, 0.3);
            border-radius: 40px; padding: 40px;
            text-align: center; color: white;
            opacity: 0; pointer-events: none;
            transition: 0.3s cubic-bezier(0.175, 0.885, 0.32, 1.27);
            box-shadow: 0 30px 80px rgba(0,0,0,0.9), inset 0 0 40px rgba(255,255,255,0.05);
        }
        #info-panel.active { 
            transform: translate(-50%, -50%) scale(1); 
            opacity: 1; 
            pointer-events: auto; 
        }
        
        .memory-icon { 
            font-size: 90px; 
            display: block; 
            margin-bottom: 15px; 
            filter: drop-shadow(0 0 40px currentColor); 
            animation: float 3s ease-in-out infinite;
        }
        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }
        
        h2 { 
            font-family: 'Fredoka One', cursive; 
            font-size: 3rem; 
            margin: 5px 0 15px 0; 
            text-transform: uppercase; 
            letter-spacing: 3px;
            text-shadow: 2px 2px 0 rgba(0,0,0,0.5), 0 0 20px currentColor;
        }
        p { 
            font-size: 1.25rem; 
            line-height: 1.6; 
            font-weight: 700; 
            opacity: 0.95; 
            color: #e8e8ff; 
        }
        
        .close-btn {
            position: absolute; top: 20px; right: 25px; font-size: 35px; 
            cursor: pointer; color: rgba(255,255,255,0.6); font-family: sans-serif; 
            transition: 0.2s; font-weight: 300;
        }
        .close-btn:hover { 
            color: white; 
            transform: rotate(90deg) scale(1.2); 
        }

        .instruction {
            position: absolute; bottom: 30px; width: 100%; text-align: center;
            color: rgba(255, 255, 255, 0.6); font-size: 15px; letter-spacing: 4px;
            font-weight: 900; text-transform: uppercase; pointer-events: none;
            text-shadow: 0 0 10px rgba(255,255,255,0.3);
            animation: pulse 2.5s ease-in-out infinite;
        }
        @keyframes pulse {
            0%, 100% { opacity: 0.4; }
            50% { opacity: 1; }
        }
    </style>
</head>
<body>

    <div id="bg-gradient"></div>
    <div class="dust"></div>

    <div class="logo-container">
        <div class="logo-main">INSIDE <span class="logo-sub">ME</span></div>
    </div>

    <div id="canvas-container" style="width:100vw; height:100vh;"></div>
    
    <div class="instruction">Hover to Pause â€¢ Click to Explore</div>

    <div id="info-panel">
        <div class="close-btn">Ã—</div>
        <div class="memory-icon" id="panel-emoji"></div>
        <h2 id="panel-title">JOY</h2>
        <p id="panel-desc">Description here...</p>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        // --- 1. CONFIGURATION ---
        const IMAGE_JOY = 'https://placehold.co/400x600/FFD700/ffffff?text=JOY+PNG'; 
        const IMAGE_SADNESS = 'https://placehold.co/400x600/4A90E2/ffffff?text=SADNESS+PNG';

        // --- 2. MOVIE-ACCURATE MARBLE TEXTURE ---
        // Creates white cloudy swirls with subtle color tint like Inside Out memory orbs
        function createCloudyMarbleTexture(colorHex) {
            const size = 512;
            const canvas = document.createElement('canvas'); 
            canvas.width = size; canvas.height = size;
            const ctx = canvas.getContext('2d');
            const color = new THREE.Color(colorHex);
            
            // Start with mostly white base with hint of color
            const baseColor = `rgb(${Math.floor(color.r*80 + 175)}, ${Math.floor(color.g*80 + 175)}, ${Math.floor(color.b*80 + 175)})`;
            ctx.fillStyle = baseColor;
            ctx.fillRect(0, 0, size, size);

            // Add pure white cloudy swirls (most prominent)
            ctx.filter = 'blur(40px)';
            ctx.globalAlpha = 0.9;
            for(let i=0; i<12; i++) {
                ctx.beginPath();
                const startX = Math.random() * size;
                const startY = Math.random() * size;
                ctx.moveTo(startX, startY);
                for(let j=0; j<3; j++) {
                    ctx.bezierCurveTo(
                        Math.random()*size, Math.random()*size,
                        Math.random()*size, Math.random()*size,
                        Math.random()*size, Math.random()*size
                    );
                }
                ctx.strokeStyle = 'rgba(255, 255, 255, 0.95)';
                ctx.lineWidth = Math.random()*100 + 60;
                ctx.lineCap = 'round';
                ctx.stroke();
            }

            // Subtle colored swirls
            ctx.filter = 'blur(35px)';
            ctx.globalAlpha = 0.3;
            for(let i=0; i<6; i++) {
                ctx.beginPath();
                ctx.moveTo(Math.random()*size, Math.random()*size);
                ctx.bezierCurveTo(
                    Math.random()*size, Math.random()*size,
                    Math.random()*size, Math.random()*size,
                    Math.random()*size, Math.random()*size
                );
                ctx.strokeStyle = `rgba(${Math.floor(color.r*255)}, ${Math.floor(color.g*255)}, ${Math.floor(color.b*255)}, 0.4)`;
                ctx.lineWidth = Math.random()*70 + 40;
                ctx.lineCap = 'round';
                ctx.stroke();
            }

            // Bright white highlights
            ctx.filter = 'blur(20px)';
            ctx.globalAlpha = 0.8;
            for(let i=0; i<25; i++) {
                ctx.beginPath();
                ctx.arc(Math.random()*size, Math.random()*size, Math.random()*40+15, 0, Math.PI*2);
                ctx.fillStyle = 'rgba(255, 255, 255, 0.9)';
                ctx.fill();
            }

            return new THREE.CanvasTexture(canvas);
        }

        // --- 3. SCENE SETUP ---
        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        // Purple fog like HQ
        scene.fog = new THREE.FogExp2(0x2a1545, 0.012);

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 6, 18); 
        camera.lookAt(0, 3, 0);

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.toneMapping = THREE.ReinhardToneMapping;
        renderer.toneMappingExposure = 1.4;
        container.appendChild(renderer.domElement);

        // --- 4. LIGHTING ---
        scene.add(new THREE.AmbientLight(0xffffff, 0.6));
        const spotLight = new THREE.SpotLight(0xffffff, 1.5);
        spotLight.position.set(0, 25, 0); 
        spotLight.penumbra = 0.5; 
        scene.add(spotLight);
        
        // Purple/Blue rim lights for HQ atmosphere
        const rimLight1 = new THREE.PointLight(0x8a2be2, 2, 40);
        rimLight1.position.set(-15, 8, -10); 
        scene.add(rimLight1);
        
        const rimLight2 = new THREE.PointLight(0x4169e1, 1.5, 35);
        rimLight2.position.set(15, 5, -8); 
        scene.add(rimLight2);

        // --- 5. MATERIALS ---
        const consoleMaterial = new THREE.MeshStandardMaterial({ 
            color: 0xf5f5fa, 
            roughness: 0.2, 
            metalness: 0.15, 
            emissive: 0x1a1a2e, 
            emissiveIntensity: 0.15 
        });
        const trackMaterial = new THREE.MeshStandardMaterial({ 
            color: 0x9999ff, 
            emissive: 0x4444ff, 
            emissiveIntensity: 0.6, 
            roughness: 0.25, 
            metalness: 0.3
        });

        // --- 6. LONG TERM MEMORY SHELVES (Inside Out HQ Background) ---
        const memoryShelvesGroup = new THREE.Group();
        
        // Create vertical columns of memory orbs in a circular arrangement
        const shelfColors = [0xFFD700, 0x4A90E2, 0xE74C3C, 0x7FD67F, 0xA359FF, 0xFF6B9D];
        const numColumns = 24; // Number of vertical columns around the circle
        const columnRadius = 30; // How far from center
        const orbsPerColumn = 40; // Orbs stacked vertically
        const orbSize = 0.3;
        
        for(let col = 0; col < numColumns; col++) {
            const angle = (col / numColumns) * Math.PI * 2;
            const x = Math.cos(angle) * columnRadius;
            const z = Math.sin(angle) * columnRadius - 10; // Shifted back
            
            for(let row = 0; row < orbsPerColumn; row++) {
                const y = (row * 0.8) - 8; // Stack vertically with small gaps
                const color = shelfColors[Math.floor(Math.random() * shelfColors.length)];
                
                const orbGeo = new THREE.SphereGeometry(orbSize, 12, 12);
                const orbMat = new THREE.MeshBasicMaterial({ 
                    color: color,
                    transparent: true,
                    opacity: 0.7 + Math.random() * 0.3
                });
                const orb = new THREE.Mesh(orbGeo, orbMat);
                orb.position.set(x, y, z);
                
                // Add glow to some orbs
                if(Math.random() > 0.7) {
                    const light = new THREE.PointLight(color, 0.5, 3);
                    orb.add(light);
                }
                
                memoryShelvesGroup.add(orb);
            }
            
            // Add vertical shelf structure (pipes)
            const pipeGeo = new THREE.CylinderGeometry(0.15, 0.15, 32, 8);
            const pipeMat = new THREE.MeshStandardMaterial({ 
                color: 0x6a4c93, 
                metalness: 0.4, 
                roughness: 0.6,
                emissive: 0x3a2c53,
                emissiveIntensity: 0.3
            });
            const pipe = new THREE.Mesh(pipeGeo, pipeMat);
            pipe.position.set(x, 8, z);
            memoryShelvesGroup.add(pipe);
        }
        
        // Add horizontal connecting beams
        for(let i = 0; i < 8; i++) {
            const y = (i * 4) - 6;
            const ringGeo = new THREE.TorusGeometry(columnRadius, 0.12, 8, 32);
            const ringMat = new THREE.MeshStandardMaterial({ 
                color: 0x4a3570,
                metalness: 0.3,
                roughness: 0.7
            });
            const ring = new THREE.Mesh(ringGeo, ringMat);
            ring.rotation.x = Math.PI / 2;
            ring.position.set(0, y, -10);
            memoryShelvesGroup.add(ring);
        }
        
        scene.add(memoryShelvesGroup);


        // --- 7. CONSOLE GEOMETRY ---
        const standGroup = new THREE.Group();
        scene.add(standGroup);

        const points = [
            new THREE.Vector2(2.2, 0), 
            new THREE.Vector2(1.2, 2.0), 
            new THREE.Vector2(1.2, 3.5), 
            new THREE.Vector2(4.5, 5.0), 
            new THREE.Vector2(4.5, 5.5)
        ];
        const stand = new THREE.Mesh(new THREE.LatheGeometry(points, 64), consoleMaterial);
        stand.position.y = -3.5;
        standGroup.add(stand);

        const trackGeo = new THREE.RingGeometry(2.5, 4.4, 64);
        const track = new THREE.Mesh(trackGeo, trackMaterial);
        track.rotation.x = -Math.PI / 2;
        track.position.y = 1.75;
        scene.add(track);

        const lid = new THREE.Mesh(new THREE.CylinderGeometry(4.5, 4.5, 0.3, 64), consoleMaterial);
        lid.position.y = 4.35; 
        scene.add(lid);

        const pillar = new THREE.Mesh(
            new THREE.CylinderGeometry(1.2, 1.2, 3.5, 32), 
            new THREE.MeshPhysicalMaterial({
                color: 0xffffff, 
                transmission: 0.6, 
                opacity: 0.85, 
                transparent: true,
                roughness: 0.1
            })
        );
        pillar.position.y = 2.0;
        scene.add(pillar);

        // --- 8. MEMORY ORBS (Movie-Accurate Texture) ---
        const carousel = new THREE.Group();
        carousel.position.y = 2.95; 
        scene.add(carousel);
        
        const clickables = []; 
        const memories = [
            { id: 'joy', color: 0xFFD700, emoji: 'ðŸ˜Š', title: 'JOY', text: 'This golden memory represents pure happiness! Keep it safe in Headquarters!' },
            { id: 'sadness', color: 0x4A90E2, emoji: 'ðŸ˜¢', title: 'SADNESS', text: 'Crying helps me slow down and think about life\'s problems.' },
            { id: 'anger', color: 0xE74C3C, emoji: 'ðŸ˜ ', title: 'ANGER', text: 'Can I say that curse word now? That is absolutely unfair!' },
            { id: 'disgust', color: 0x7FD67F, emoji: 'ðŸ¤¢', title: 'DISGUST', text: 'Ew, gross! I\'m keeping us away from poison... or bad fashion.' },
            { id: 'fear', color: 0xA359FF, emoji: 'ðŸ˜¨', title: 'FEAR', text: 'We did not die today! I\'d call that an unqualified success!' },
            { id: 'envy', color: 0x00CED1, emoji: 'ðŸ¥º', title: 'ENVY', text: 'I really want to be like Val... is that so wrong?' }
        ];

        const radius = 3.3;
        const step = (Math.PI * 2) / memories.length;

        memories.forEach((mem, i) => {
            const angle = i * step;
            
            const orbGeo = new THREE.SphereGeometry(1.2, 64, 64);
            const orbMat = new THREE.MeshPhysicalMaterial({
                color: mem.color, 
                map: createCloudyMarbleTexture(mem.color),
                metalness: 0.1, 
                roughness: 0.15, 
                clearcoat: 1.0, 
                clearcoatRoughness: 0.05,
                emissive: mem.color, 
                emissiveIntensity: 0.35,
                transparent: true,
                opacity: 0.95
            });

            const orb = new THREE.Mesh(orbGeo, orbMat);
            orb.position.set(Math.cos(angle) * radius, 0, Math.sin(angle) * radius);
            orb.add(new THREE.PointLight(mem.color, 2.5, 6));

            orb.userData = mem; 
            carousel.add(orb);
            clickables.push(orb);
        });

        // Top Core Orb
        const coreGeo = new THREE.SphereGeometry(1.3, 64, 64);
        const coreMat = new THREE.MeshPhysicalMaterial({
            color: 0xFFD700, 
            map: createCloudyMarbleTexture(0xFFD700),
            roughness: 0.1, 
            emissive: 0xFFD700, 
            emissiveIntensity: 0.5,
            clearcoat: 1.0,
            transparent: true,
            opacity: 0.95
        });
        const coreOrb = new THREE.Mesh(coreGeo, coreMat);
        coreOrb.position.set(0, 5.75, 0); 
        
        coreOrb.userData = { 
            emoji: 'â­', 
            title: 'CORE MEMORY', 
            text: 'This is a Core Memory! It powers an Island of Personality and makes you who you are!', 
            color: 0xFFD700 
        };
        scene.add(coreOrb);
        clickables.push(coreOrb);


        // --- 9. CHARACTERS ---
        const textureLoader = new THREE.TextureLoader();
        function addCharacter(url, x) {
            textureLoader.load(url, (texture) => {
                const mat = new THREE.SpriteMaterial({ map: texture, transparent: true, opacity: 0.9 });
                const sprite = new THREE.Sprite(mat);
                sprite.scale.set(8, 12, 1);
                sprite.position.set(x, 3.5, -4);
                scene.add(sprite);
            }, undefined, (err) => console.log("Character image not loaded"));
        }
        addCharacter(IMAGE_JOY, -11);
        addCharacter(IMAGE_SADNESS, 11);


        // --- 10. INTERACTION ---
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        let isHovering = false;
        let rotationSpeed = 0.015;

        window.addEventListener('mousemove', (e) => {
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            isHovering = raycaster.intersectObjects(clickables).length > 0;
            document.body.style.cursor = isHovering ? 'pointer' : 'default';
        });

        window.addEventListener('click', () => {
            if (isHovering) {
                raycaster.setFromCamera(mouse, camera);
                const intersects = raycaster.intersectObjects(clickables);
                if (intersects.length > 0) showPanel(intersects[0].object.userData);
            } else hidePanel();
        });

        const panel = document.getElementById('info-panel');
        function showPanel(data) {
            document.getElementById('panel-emoji').innerText = data.emoji;
            document.getElementById('panel-emoji').style.color = '#' + data.color.toString(16).padStart(6, '0');
            const title = document.getElementById('panel-title');
            title.innerText = data.title;
            title.style.color = '#' + data.color.toString(16).padStart(6, '0');
            document.getElementById('panel-desc').innerText = data.text;
            panel.style.boxShadow = `0 0 80px #${data.color.toString(16).padStart(6, '0')}, 0 30px 80px rgba(0,0,0,0.9)`;
            panel.style.borderColor = '#' + data.color.toString(16).padStart(6, '0');
            panel.classList.add('active');
        }
        function hidePanel() { panel.classList.remove('active'); }
        document.querySelector('.close-btn').addEventListener('click', hidePanel);
        
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // --- 11. ANIMATION ---
        function animate() {
            requestAnimationFrame(animate);

            const targetSpeed = isHovering ? 0 : 0.015; 
            rotationSpeed += (targetSpeed - rotationSpeed) * 0.1;
            carousel.rotation.y -= rotationSpeed;

            const time = Date.now() * 0.001;
            carousel.position.y = 2.95 + Math.sin(time) * 0.05;
            coreOrb.position.y = 5.75 + Math.sin(time*1.2) * 0.1;
            coreOrb.rotation.y += 0.005;
            
            // Animate memory shelves - slow rotation
            memoryShelvesGroup.rotation.y += 0.0002;
            
            // Gentle light pulsing
            rimLight1.intensity = 2 + Math.sin(time * 0.5) * 0.3;
            rimLight2.intensity = 1.5 + Math.cos(time * 0.7) * 0.2;

            renderer.render(scene, camera);
        }
        animate();
    </script>
</body>
</html>